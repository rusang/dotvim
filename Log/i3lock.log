#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
	
#include "meta_data.h"
	
#define DBG	printf
#define LOG	printf
#define INFO	printf
	
static double Y[M][N];
static double Z[M][N];
static double P[M][N];
static double H[N];
static double W[N];

#define max(a, b) (((a) > (b)) ? (a) : (b))
#define min(a, b) (((a) < (b)) ? (a) : (b))

#define __unused __attribute__((unused))

static const char *provinces[M] = {
	"北京  ",
	"天津  ",
	"河北  ",
	"山西  ",
	"内蒙古",
	"辽宁  ",
	"吉林  ",
	"黑龙江",
	"上海  ",
	"江苏  ",
	"浙江  ",
	"安徽  ",
	"福建  ",
	"江西  ",
	"山东  ",
	"河南  ",
	"湖北  ",
	"湖南  ",
	"广东  ",
	"广西  ",
	"海南  ",
	"重庆  ",
	"四川  ",
	"贵州  ",
	"云南  ",
	"西藏  ",
	"陕西  ",
	"甘肃  ",
	"青海  ",
	"宁夏  ",
	"新疆  ",
};

#if 0
__unused static const char *criterions[N] = {
	"结余率",
	"总资产周转次数",
	"净资产增长率",
	"资产负债率",
	"病床使用率",
};
#endif

static void __dump_matrix_mn(const char *prefix, double matrix[M][N])
{
	int i, j;

	DBG("-------------------------------------------------\n");

	DBG("%s:\n", prefix);

	for (i = 0; i < M; i++) {
		DBG("%2d %-3s", i + 1, provinces[i]);
		for (j = 0; j < N; j++) {
			DBG("  %.6lf", matrix[i][j]);
		}
		DBG("\n");
	}
	
	DBG("-------------------------------------------------\n");
}

static void __dump_matrix_n(const char *prefix, double matrix[N])
{
	int j;

	INFO("-------------------------------------------------\n");

	INFO("%s:\n", prefix);

	for (j = 0; j < N; j++) {
		INFO("%.32lf  ", matrix[j]);
	}
	INFO("\n");
	
	INFO("-------------------------------------------------\n");
}

/*
 * Yij = (Xij - minXij)/ (maxXij - minXij)
 *             i        i       i
 */
static void __calc_Y(void)
{
	int i, j;
	double maxij, minij;

	for (j = 0; j < N; j++) {
		/* get maxXij and minXij */
		maxij = X[0][j];
		minij = X[0][j];
		for (i = 0; i < M; i++) {
			maxij = max(maxij, X[i][j]);
			minij = min(minij, X[i][j]);
		}

		DBG("[%2d] max:%20.10lf	min:%20.10lf\n", j + 1, maxij, minij);

		for (i = 0; i < M; i++) {
			Y[i][j] = (X[i][j] - minij) / (maxij - minij);
			//Y[i][j] = (maxij - X[i][j]) / (maxij - minij);
		}
	}
}

static void __translation_transformation(void)
{
	int i, j;
	double yij_ = 0;
	double c, d;
	double sum_yij_yij_ = 0;
	double yij_yij_;
	double sum_yij = 0;

	for (j = 0; j < N; j++) {
		for (i = 0; i < M; i++)
			yij_ += Y[i][j];

		yij_ = yij_ / M;

		sum_yij_yij_ = 0;
		sum_yij = 0;

		/* calc c and d */
		for (i = 0; i < M; i++) {
			yij_yij_ += (Y[i][j] - yij_);
			sum_yij_yij_ += (yij_yij_ * yij_yij_);
			sum_yij += Y[i][j];
		}
		c = sum_yij / (sqrt(sum_yij_yij_));
		d = 1 / (sqrt(sum_yij_yij_));
		DBG("[%2d]: c:%10.6lf	d:%10.6lf\n", j + 1, c, d);
		for (i = 0; i < M; i++) {
			Z[i][j] = c + Y[i][j] * d;
		}
	}

}

static void __calc_P(void)
{
	int i, j;
	double sum_zij = 0;

	for (j = 0; j < N; j++) {
		sum_zij = 0;
		for (i = 0; i < M; i++) {
			sum_zij += Z[i][j];
		}

		for (i = 0; i < M; i++) {
			P[i][j] = Z[i][j] / sum_zij;
		}
	}
}

static void __calc_H(void)
{
	int i, j;
	double sum_pij_lnpij = 0;

	for (j = 0; j < N; j++) {
		sum_pij_lnpij = 0;
		for (i = 0; i < M; i++) {
			sum_pij_lnpij += (P[i][j] * log(P[i][j]));
		}
		H[j] = - sum_pij_lnpij / log(M);
	}

}

static void __calc_W(void)
{
	int j;
	double sum = 0;

	for (j = 0; j < N; j++)
		sum += (1 - H[j]);

	for (j = 0; j < N; j++)
		W[j] = (1 - H[j]) / sum;
}

__unused static void __shanxi_method(void)
{
	__dump_matrix_mn("X", X);

	__calc_Y();

	__dump_matrix_mn("Y", Y);

	__translation_transformation();

	__dump_matrix_mn("Z", Z);

	__calc_P();

	__dump_matrix_mn("P", P);

	__calc_H();
	
	__dump_matrix_n("H", H);

	__calc_W();
	
	__dump_matrix_n("W", W);
}

static double Z_[M][N];
static double S_[N];
static double D_[N];
static double W_[N];

static void __calc_Z_(void)
{
	int i, j;
	double sum_xij = 0;

	for (j = 0; j < N; j++) {
		sum_xij = 0;
		for (i = 0; i < M; i++) {
			sum_xij += (X[i][j] * X[i][j]);
		}

		for (i = 0; i < M; i++) {
			Z_[i][j] = X[i][j] / (sqrt(sum_xij));
		}
	}
}

static void __calc_S_(void)
{
	int i, j;
	double sum_zij = 0;
	
	for (j = 0; j < N; j++) {
		sum_zij = 0;
		for (i = 0; i < M; i++) {
			sum_zij += (Z_[i][j] * log(Z_[i][j]));
		}

		S_[j] = - sum_zij / log(M);
	}
	
}

static void __calc_D_(void)
{
	int j;
	
	for (j = 0; j < N; j++)
		D_[j] = 1 - S_[j];
}

static void __calc_W_(void)
{
	int j;
	double sum = 0;

	for (j = 0; j < N; j++)
		sum += D_[j];

	LOG("sum is %lf\n", sum);

	W_[j] = D_[j] / sum;
}

__unused static void __method2(void)
{
	__dump_matrix_mn("X", X);

	__calc_Z_();
	__dump_matrix_mn("Z_", Z_);

	__calc_S_();
	__dump_matrix_n("S_", S_);

	__calc_D_();
	__dump_matrix_n("D_", D_);

	__calc_W_();
	__dump_matrix_n("W_", W_);
}

int main(void)
{
	__shanxi_method();
	//__method2();

	//LOG("%lf\n", sqrt(9.0));
	//LOG("%lf\n", log(2.718));
	return 0;
}

/* vim: set ts=8 sts=8 sw=8 noexpandtab: */

/////////////////////////////////////////////
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#define DBG	printf
#define LOG	printf
#define INFO	printf
	
#define max(a, b) (((a) > (b)) ? (a) : (b))
#define min(a, b) (((a) < (b)) ? (a) : (b))

#define __unused __attribute__((unused))
	
#if 1
#define M	31
#define N	16

static const char *provinces[M] = {
	"北京  ",
	"天津  ",
	"河北  ",
	"山西  ",
	"内蒙古",
	"辽宁  ",
	"吉林  ",
	"黑龙江",
	"上海  ",
	"江苏  ",
	"浙江  ",
	"安徽  ",
	"福建  ",
	"江西  ",
	"山东  ",
	"河南  ",
	"湖北  ",
	"湖南  ",
	"广东  ",
	"广西  ",
	"海南  ",
	"重庆  ",
	"四川  ",
	"贵州  ",
	"云南  ",
	"西藏  ",
	"陕西  ",
	"甘肃  ",
	"青海  ",
	"宁夏  ",
	"新疆  ",
};

double X[M][N] = {
	{0.010948282 , 1.092823238 , 0.065320516 , 0.394764758 , 0.824 , 10.1 , 9.3  , 1.4 , 16.78269885 , 113664 , 0.790885379 , 0.465170704 , 0.109791504 , 516.8 , 21737.2 , 0.127877442} ,
	{0.038728162 , 0.946165766 , 0.097391997 , 0.41039427  , 0.781 , 10.1 , 10.4 , 1.6 , 15.75602288 , 60158  , 0.821384252 , 0.425005444 , 0.032501882 , 316.8 , 16526.7 , 0.053153704} ,
	{0.042169292 , 0.721913842 , 0.178508633 , 0.441803372 , 0.837 , 8.8  , 5.2  , 2.2 , 16.81631181 , 299523 , 0.823859083 , 0.4521019   , 0.129676162 , 222.8 , 8417.8  , 0.13971025}  ,
	{0.030187144 , 0.727649815 , 0.239138186 , 0.390644806 , 0.776 , 10.4 , 4.2  , 2.1 , 16.04419881 , 154184 , 0.824410706 , 0.482494998 , 0.100016741 , 240.8 , 8437.7  , 0.119034624} ,
	{0.010382677 , 0.696052988 , 0.107601391 , 0.477256678 , 0.747 , 9.8  , 5.1  , 2.2 , 15.92386251 , 118697 , 0.823994595 , 0.472528611 , 0.082457794 , 231.6 , 8324.4  , 0.105628643} ,
	{0.020141139 , 0.844938791 , 0.085911714 , 0.547258002 , 0.82   , 10.5 , 5.3  , 2.7 , 16.34763367 , 252969 , 0.814830727 , 0.489814309 , 0.075209439 , 281.7 , 8958.1  , 0.079053847} ,
	{0.040218464 , 0.803907926 , 0.109674733 , 0.454843681 , 0.776 , 9.4  , 5    , 2.3 , 15.90846711 , 126595 , 0.802917172 , 0.467585559 , 0.089877406 , 267.1 , 9270.3  , 0.110632676} ,
	{0.012696026 , 0.76649005  , 0.099544264 , 0.494590398 , 0.789 , 10.5 , 4.7  , 2.7 , 16.18920814 , 200838 , 0.818380947 , 0.454876943 , 0.075347607 , 257   , 8689.3  , 0.068468186} ,
	{0.020863802 , 1.283122776 , 0.0748496   , 0.289018196 , 0.954 , 10.1 , 14.8 , 2.6 , 16.45530811 , 115916 , 0.836712475 , 0.497074292 , 0.125655513 , 361   , 18185.2 , 0.126120156} ,
	{0.009848421 , 0.890910939 , 0.085372034 , 0.46290442  , 0.875 , 9.5  , 8.7  , 2.6 , 17.22941463 , 369784 , 0.830912319 , 0.502263474 , 0.103986143 , 260.8 , 10597.9 , 0.11344861}  ,
	{0.018782297 , 0.989303361 , 0.065908732 , 0.40700364  , 0.894 , 9.8  , 11.4 , 2.4 , 17.02615572 , 277076 , 0.825998779 , 0.478354316 , 0.126495315 , 245   , 11310.4 , 0.128571907} ,
	{0.070239815 , 0.731096534 , 0.175406386 , 0.458531692 , 0.862 , 8.7  , 6.2  , 2.7 , 16.57574978 , 233219 , 0.847231689 , 0.513275095 , 0.129032671 , 226.3 , 6993.3  , 0.139867729} ,
	{0.053786802 , 0.809530478 , 0.148408964 , 0.314687748 , 0.831 , 8.6  , 8.6  , 2.4 , 16.24756858 , 139362 , 0.834326349 , 0.506969338 , 0.078562445 , 233.1 , 8544.6  , 0.095683908} ,
	{0.044086324 , 0.783952809 , 0.250795628 , 0.426439778 , 0.858 , 8.9  , 5.9  , 2.9 , 16.18670814 , 160095 , 0.85491099  , 0.510614326 , 0.105640751 , 238.7 , 7537.6  , 0.107514935} ,
	{0.033199312 , 0.804554561 , 0.134722005 , 0.469472305 , 0.834 , 8.6  , 5.9  , 2.2 , 17.25074647 , 441032 , 0.846395695 , 0.485129179 , 0.103937234 , 244.2 , 9057.1  , 0.100061262} ,
	{0.039126022 , 0.735507247 , 0.105255132 , 0.556087205 , 0.884 , 9.6  , 6.1  , 2.8 , 17.04227137 , 413827 , 0.831171879 , 0.487240798 , 0.154331863 , 183.2 , 7739.9  , 0.170585725} ,
	{0.026367022 , 0.744565849 , 0.114918774 , 0.43740526  , 0.927 , 9.5  , 6.9  , 3   , 16.8160203  , 270862 , 0.838513418 , 0.521576493 , 0.108587036 , 229.1 , 8512.7  , 0.135406512} ,
	{0.030550274 , 0.807268015 , 0.09668632  , 0.537170571 , 0.852 , 9.1  , 4.6  , 2.9 , 16.71888162 , 319455 , 0.838064506 , 0.502116764 , 0.123047613 , 279.4 , 7748.3  , 0.123789142} ,
	{0.030706535 , 1.099940599 , 0.070107693 , 0.39317761  , 0.84   , 8.7  , 10.6 , 2.3 , 17.28543667 , 393449 , 0.834495794 , 0.482490824 , 0.112450387 , 253   , 10922.4 , 0.124144486} ,
	{0.039208956 , 0.877342818 , 0.103003957 , 0.422740509 , 0.877 , 8.6  , 7.8  , 2.7 , 16.26019182 , 161506 , 0.820498701 , 0.507171407 , 0.129506124 , 191.2 , 8028.1  , 0.130838979} ,
	{0.019573347 , 0.587046905 , 0.088415426 , 0.401395086 , 0.811 , 8.9  , 6.4  , 2.1 , 15.16353124 , 32514  , 0.808423407 , 0.510454804 , 0.113092109 , 246.9 , 9701.4  , 0.151639661} ,
	{0.045903242 , 0.843655937 , 0.08056642  , 0.422736105 , 0.841 , 9.3  , 7.2  , 3.2 , 16.11496776 , 150545 , 0.799362853 , 0.512261361 , 0.119273899 , 296.7 , 7885.1  , 0.135160102} ,
	{0.039135381 , 0.816182483 , 0.115587152 , 0.37163135  , 0.913 , 10.5 , 7    , 3.4 , 17.01784627 , 411911 , 0.808672858 , 0.503102278 , 0.130793254 , 238   , 7592.5  , 0.130556819} ,
	{0.037644386 , 0.72426971  , 0.312833277 , 0.504255355 , 0.799 , 8.2  , 5.7  , 3   , 16.1003602  , 178296 , 0.83829239  , 0.496568937 , 0.143038916 , 232.3 , 5727.9  , 0.160117832} ,
	{0.058316707 , 0.809038468 , 0.120430597 , 0.410667908 , 0.832 , 8.5  , 7.6  , 3.1 , 16.3445136  , 210840 , 0.845736201 , 0.509850386 , 0.109599961 , 199.3 , 6235    , 0.147263507} ,
	{0.224717284 , 0.678367682 , 0.337011048 , 0.168637651 , 0.721 , 8.7  , 5.9  , 1.7 , 13.78110957 , 11749  , 0.763389831 , 0.329780935 , 0.149373207 , 168.5 , 7206    , 0.035447428} ,
	{0.034807923 , 0.779647231 , 0.103841496 , 0.429283051 , 0.837 , 9.1  , 6    , 2.8 , 16.23059658 , 193150 , 0.849256874 , 0.472617452 , 0.125779264 , 225.2 , 7003.1  , 0.13586905}  ,
	{0.052210088 , 0.674032085 , 0.304484976 , 0.362613128 , 0.816 , 8.8  , 6.2  , 2.7 , 15.77560914 , 111206 , 0.837267829 , 0.462369014 , 0.126439476 , 190.9 , 5769.8  , 0.134739503} ,
	{0.056624094 , 0.676236324 , 0.177057364 , 0.313756044 , 0.706 , 9    , 5.3  , 2.2 , 14.65730573 , 32028  , 0.838685326 , 0.460222945 , 0.095428057 , 199.1 , 8185.5  , 0.128472751} ,
	{0.057603275 , 0.845657549 , 0.09526551  , 0.504007453 , 0.808 , 8.9  , 6.8  , 2.3 , 14.59880553 , 34822  , 0.82942628  , 0.491747003 , 0.079195719 , 225.5 , 7410.1  , 0.054539628} ,
	{0.043791772 , 0.7911407   , 0.089525968 , 0.379714606 , 0.85   , 8.5  , 5.8  , 2.7 , 15.93205724 , 131212 , 0.81994762  , 0.452177007 , 0.090861617 , 221.9 , 7046.8  , 0.075124591} ,
};
#else
#define M	11
#define N	18

static const char *provinces[M] = {
	"2006",
	"2007",
	"2008",
	"2009",
	"2010",
	"2011",
	"2012",
	"2013",
	"2014",
	"2015",
	"2016"
};

double X[M][N] = {
	{644885  , 24715 , 24709 , 8977  , 12.64 , 58.36  , 30.50 , 98.10 , 94.96 , 99.88  , 98.89 , 99.75 , 99.79  , 92.71 , 0.92 , 0.00 , 0.10 , 99.20} ,
	{722771  , 26342 , 26264 , 10524 , 12.20 , 57.69  , 32.28 , 98.07 , 90.91 , 99.81  , 99.03 , 99.74 , 99.75  , 93.18 , 0.77 , 0.02 , 0.06 , 99.83} ,
	{829422  , 31558 , 31424 , 13057 , 11.88 , 68.24  , 31.87 , 98.38 , 86.20 , 99.88  , 99.32 , 99.88 , 99.91  , 91.87 , 0.26 , 0.00 , 0.13 , 99.91} ,
	{1032512 , 44009 , 43502 , 16076 , 11.72 , 87.82  , 32.60 , 98.43 , 83.57 , 99.89  , 99.36 , 99.86 , 99.95  , 91.13 , 0.18 , 0.00 , 0.13 , 99.90} ,
	{1271463 , 61248 , 61120 , 25466 , 11.11 , 112.87 , 34.11 , 98.72 , 78.61 , 100.00 , 99.69 , 99.90 , 99.91  , 94.04 , 0.12 , 0.00 , 0.01 , 99.90} ,
	{411697  , 67484 , 67378 , 27295 , 10.94 , 123.32 , 34.41 , 98.95 , 81.72 , 100.00 , 99.82 , 99.94 , 99.97  , 94.24 , 0.09 , 0.00 , 0.00 , 99.87} ,
	{594132  , 68282 , 68272 , 28744 , 10.67 , 121.09 , 35.25 , 98.93 , 82.87 , 99.74  , 99.85 , 99.91 , 99.94  , 97.69 , 0.35 , 0.02 , 0.01 , 99.97} ,
	{725096  , 70098 , 69896 , 28105 , 10.40 , 118.90 , 36.61 , 99.07 , 83.06 , 99.79  , 99.93 , 99.95 , 99.98  , 97.06 , 0.26 , 0.04 , 0.00 , 99.98} ,
	{864543  , 72319 , 72510 , 22178 , 10.26 , 121.41 , 37.11 , 99.15 , 88.95 , 99.85  , 99.93 , 99.96 , 99.99  , 97.03 , 0.34 , 0.01 , 0.00 , 99.96} ,
	{906261  , 66467 , 66602 , 19850 , 10.34 , 90.47  , 40.92 , 99.10 , 88.87 , 99.91  , 99.94 , 99.97 , 100.00 , 93.17 , 0.32 , 0.02 , 0.00 , 99.97} ,
	{800751  , 63766 , 63913 , 20472 , 10.46 , 81.74  , 41.27 , 99.16 , 89.33 , 99.93  , 99.85 , 99.93 , 99.99  , 94.62 , 0.31 , 0.01 , 0.00 , 99.97} ,
};
#endif
	

#if 0
__unused static const char *criterions[N] = {
	"结余率",
	"总资产周转次数",
	"净资产增长率",
	"资产负债率",
	"病床使用率",
};
#endif

static double Y[M][N];
static double Z[M][N];
static double P[M][N];
static double H[N];
static double W[N];

static void __dump_matrix_mn(const char *prefix, double matrix[M][N])
{
	int i, j;

	DBG("-------------------------------------------------\n");

	DBG("%s:\n", prefix);

	for (i = 0; i < M; i++) {
		DBG("%2d %-3s", i + 1, provinces[i]);
		for (j = 0; j < N; j++) {
			DBG("  %.6lf", matrix[i][j]);
		}
		DBG("\n");
	}
	
	DBG("-------------------------------------------------\n");
}

static void __dump_matrix_n(const char *prefix, double matrix[N])
{
	int j;

	INFO("-------------------------------------------------\n");

	INFO("%s:\n", prefix);

	for (j = 0; j < N; j++) {
		INFO("%.32lf  ", matrix[j]);
	}
	INFO("\n");
	
	INFO("-------------------------------------------------\n");
}

/*
 * Yij = (Xij - minXij)/ (maxXij - minXij)
 *             i        i       i
 */
static void __calc_Y(double in[M][N], double out[M][N])
{
	int i, j;
	double maxij, minij;

	for (j = 0; j < N; j++) {
		/* get maxXij and minXij */
		maxij = in[0][j];
		minij = in[0][j];
		for (i = 0; i < M; i++) {
			maxij = max(maxij, in[i][j]);
			minij = min(minij, in[i][j]);
		}

		DBG("[%2d] max:%20.10lf	min:%20.10lf\n", j + 1, maxij, minij);

		for (i = 0; i < M; i++) {
			out[i][j] = (in[i][j] - minij) / (maxij - minij);
		}
	}
}

/*
 * Yij = (Xij - minXij)/ (maxXij - minXij)
 *             i        i       i
 */
static void __calc_Y__(double in[M][N], double out[M][N])
{
	int i, j;
	double maxij, minij;

	for (j = 0; j < N; j++) {
		/* get maxXij and minXij */
		maxij = in[0][j];
		minij = in[0][j];
		for (i = 0; i < M; i++) {
			maxij = max(maxij, in[i][j]);
			minij = min(minij, in[i][j]);
		}

		DBG("[%2d] max:%20.10lf	min:%20.10lf\n", j + 1, maxij, minij);

		for (i = 0; i < M; i++) {
			if (4 == j || 14 == j || 15 == j || 16 == j)
				out[i][j] = (maxij - in[i][j]) / (maxij - minij);
			else
				out[i][j] = (in[i][j] - minij) / (maxij - minij);
		}
	}
}

static void __translation_transformation(double in[M][N], double out[M][N])
{
	int i, j;
	double yij_ = 0;
	double c, d;
	double sum_yij_yij_ = 0;
	double yij_yij_;
	double sum_yij = 0;

	for (j = 0; j < N; j++) {
		for (i = 0; i < M; i++)
			yij_ += in[i][j];

		yij_ = yij_ / M;

		sum_yij_yij_ = 0;
		sum_yij = 0;

		/* calc c and d */
		for (i = 0; i < M; i++) {
			yij_yij_ += (in[i][j] - yij_);
			sum_yij_yij_ += (yij_yij_ * yij_yij_);
			sum_yij += in[i][j];
		}
		c = sum_yij / (sqrt(sum_yij_yij_));
		d = 1 / (sqrt(sum_yij_yij_));
		DBG("[%2d]: c:%10.6lf	d:%10.6lf\n", j + 1, c, d);
		for (i = 0; i < M; i++) {
			out[i][j] = c + in[i][j] * d;
		}
	}

#if 0
	for (i = 0; i < M; i++) {
		for (j = 0; j < N; j++) {
			if (in[i][j])
				out[i][j] = in[i][j];
		}
	}
#endif

}

static void __calc_P(double in[M][N], double out[M][N])
{
	int i, j;
	double sum_zij = 0;

	for (j = 0; j < N; j++) {
		sum_zij = 0;
		for (i = 0; i < M; i++) {
			sum_zij += in[i][j];
		}

		for (i = 0; i < M; i++) {
			out[i][j] = in[i][j] / sum_zij;
		}
	}
}

static void __calc_H(double in[M][N], double out[N])
{
	int i, j;
	double sum_pij_lnpij = 0.0;

	for (j = 0; j < N; j++) {
		sum_pij_lnpij = 0;
		for (i = 0; i < M; i++) {
			sum_pij_lnpij += in[i][j] * log(in[i][j]);
		}
		out[j] = - sum_pij_lnpij / log(M);
	}
}

static void __calc_W(double in[N], double out[N])
{
	int j;
	double sum = 0;

	for (j = 0; j < N; j++)
		sum += (1 - in[j]);

	for (j = 0; j < N; j++)
		out[j] = (1 - in[j]) / sum;
}

__unused static void __shanxi_method(void)
{
	__dump_matrix_mn("X", X);

	__calc_Y(X, Y);

	__dump_matrix_mn("Y", Y);

	__translation_transformation(Y, Z);

	__dump_matrix_mn("Z", Z);

	__calc_P(Z, P);

	__dump_matrix_mn("P", P);

	__calc_H(P, H);
	
	__dump_matrix_n("H", H);

	__calc_W(H, W);

	__dump_matrix_n("W", W);
}

static double Z_[M][N];
static double S_[N];
static double D_[N];
static double W_[N];

static void __calc_Z_(void)
{
	int i, j;
	double sum_xij = 0;

	for (j = 0; j < N; j++) {
		sum_xij = 0;
		for (i = 0; i < M; i++) {
			sum_xij += (X[i][j] * X[i][j]);
		}

		for (i = 0; i < M; i++) {
			Z_[i][j] = X[i][j] / (sqrt(sum_xij));
		}
	}
}

static void __calc_S_(void)
{
	int i, j;
	double sum_zij = 0;
	
	for (j = 0; j < N; j++) {
		sum_zij = 0;
		for (i = 0; i < M; i++) {
			sum_zij += (Z_[i][j] * log(Z_[i][j]));
		}

		S_[j] = - sum_zij / log(M);
	}
	
}

static void __calc_D_(void)
{
	int j;
	
	for (j = 0; j < N; j++)
		D_[j] = 1 - S_[j];
}

static void __calc_W_(void)
{
	int j;
	double sum = 0;

	for (j = 0; j < N; j++)
		sum += D_[j];

	LOG("sum is %lf\n", sum);

	W_[j] = D_[j] / sum;
}

__unused static void __method2(void)
{
	__dump_matrix_mn("X", X);

	__calc_Z_();
	__dump_matrix_mn("Z_", Z_);

	__calc_S_();
	__dump_matrix_n("S_", S_);

	__calc_D_();
	__dump_matrix_n("D_", D_);

	__calc_W_();
	__dump_matrix_n("W_", W_);
}

static double Y__[M][N];
static double P__[M][N];
static double T__[M][N];
static double H__[N];
static double W__[N];

__unused static void __method3(void)
{
	__dump_matrix_mn("X", X);

	__calc_Y__(X, Y__);
	__dump_matrix_mn("Y", Y__);

#if 1
	__translation_transformation(Y__, T__);
	__dump_matrix_mn("T", T__);
#endif

	__calc_P(T__, P__);
	__dump_matrix_mn("P", P__);

	__calc_H(P__, H__);
	__dump_matrix_n("H", H__);

	__calc_W(H__, W__);
	__dump_matrix_n("W", W__);
}

int main(void)
{
	__shanxi_method();
	//__method2();
	//__method3();

	//LOG("%lf\n", sqrt(9.0));
	//LOG("%lf\n", log(2.718));
	return 0;
}

/* vim: set ts=8 sts=8 sw=8 noexpandtab: */

